using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

public class CustomCacheEntry
{
    public string Key { get; set; }
    public byte[] Value { get; set; }
    public DateTimeOffset? Expiration { get; set; }

    public CustomCacheEntry(string key, byte[] value, DateTimeOffset? expiration)
    {
        Key = key;
        Value = value;
        Expiration = expiration;
    }
}

public class FileDistributedCache : IDistributedCache
{
     private readonly MemoryDistributedCache memoryCache;
    private readonly string cacheFilePath;
    private readonly string encryptionPassword;
    private readonly HashSet<string> cacheKeys;

    public FileDistributedCache(IOptions<MemoryDistributedCacheOptions> optionsAccessor, string cacheFilePath, string encryptionPassword)
    {
        memoryCache = new MemoryDistributedCache(optionsAccessor);
        this.cacheFilePath = cacheFilePath;
        this.encryptionPassword = encryptionPassword;
        cacheKeys = new HashSet<string>();
        LoadFromCacheFile();
    }

    public byte[] Get(string key)
    {
        return memoryCache.Get(key);
    }

    public void Set(string key, byte[] value, DistributedCacheEntryOptions options)
    {
        memoryCache.Set(key, value, options);
        cacheKeys.Add(key);
        SaveToCacheFile();
    }

    public void Refresh(string key)
    {
        memoryCache.Refresh(key);
        UpdateExpirationInCacheFile(key);
    }

    public void Remove(string key)
    {
        memoryCache.Remove(key);
        cacheKeys.Remove(key);
        SaveToCacheFile();
    }

    private void SaveToCacheFile()
    {
        var entries = GetCacheEntries();

        var serializedEntries = JsonConvert.SerializeObject(entries);
        var encryptedData = Encrypt(serializedEntries, encryptionPassword);

        File.WriteAllText(cacheFilePath, encryptedData);
    }

    private void UpdateExpirationInCacheFile(string key)
    {
        var entries = LoadFromCacheFile();
        var entry = entries.Find(e => e.Key == key);

        if (entry != null)
        {
            entry.Expiration = DateTimeOffset.UtcNow.Add(memoryCache.GetOptions(key)?.AbsoluteExpirationRelativeToNow ?? TimeSpan.Zero);
            SaveToCacheFile();
        }
    }

    private void RemoveFromCacheFile(string key)
    {
        var entries = LoadFromCacheFile();
        entries.RemoveAll(e => e.Key == key);
        SaveToCacheFile();
    }

    private List<CustomCacheEntry> LoadFromCacheFile()
    {
        if (File.Exists(cacheFilePath))
        {
            var encryptedData = File.ReadAllText(cacheFilePath);
            var decryptedData = Decrypt(encryptedData, encryptionPassword);

            var entries = JsonConvert.DeserializeObject<List<CustomCacheEntry>>(decryptedData) ?? new List<CustomCacheEntry>();
            cacheKeys.Clear();
            cacheKeys.UnionWith(entries.Select(e => e.Key));
            return entries;
        }

        return new List<CustomCacheEntry>();
    }

    private List<CustomCacheEntry> GetCacheEntries()
    {
        var entries = new List<CustomCacheEntry>();

        foreach (var key in cacheKeys)
        {
            var value = memoryCache.Get(key);
            var expiration = DateTimeOffset.UtcNow.Add(memoryCache.GetOptions(key)?.AbsoluteExpirationRelativeToNow ?? TimeSpan.Zero);
            entries.Add(new CustomCacheEntry(key, value, expiration));
        }

        return entries;
    }


    private string Encrypt(string data, string password)
    {
        using (Aes aesAlg = Aes.Create())
        {
            Rfc2898DeriveBytes keyDerivation = new Rfc2898DeriveBytes(password, aesAlg.KeySize / 8);
            aesAlg.Key = keyDerivation.GetBytes(aesAlg.KeySize / 8);

            using (MemoryStream msEncrypt = new MemoryStream())
            {
                using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, aesAlg.CreateEncryptor(), CryptoStreamMode.Write))
                using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                {
                    swEncrypt.Write(data);
                }

                return Convert.ToBase64String(msEncrypt.ToArray());
            }
        }
    }

    private string Decrypt(string encryptedData, string password)
    {
        using (Aes aesAlg = Aes.Create())
        {
            Rfc2898DeriveBytes keyDerivation = new Rfc2898DeriveBytes(password, aesAlg.KeySize / 8);
            aesAlg.Key = keyDerivation.GetBytes(aesAlg.KeySize / 8);

            using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(encryptedData)))
            using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, aesAlg.CreateDecryptor(), CryptoStreamMode.Read))
            using (StreamReader srDecrypt = new StreamReader(csDecrypt))
            {
                return srDecrypt.ReadToEnd();
            }
        }
    }
}
